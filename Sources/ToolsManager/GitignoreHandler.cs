using SpearSettings;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ToolsManager
{
    /* 
    -- .gitignore format --
    #
    # Manually added files (add down below any file you want to gitignore)
    #

    #
    # User-defined folders
    #

    #
    # Default extensions
    #

    #
    # Augo-generated by spear.exe
    #
    */

    public class GitignoreHandler
    {
        private readonly List<string> constBlackListName = new List<string> { Consts.FILE_INTEGRITYFILE };
        private readonly List<string> constBlackListStartWith = new List<string> { @".git/" };
        private List<string> ignoreDirs;
        private List<string> ignoreExtensions;
        private string rootDir;
        private string gitignorePath;

        public GitignoreHandler(string repoRoot, List<string> gitignoreDirs, List<string> gitignoreExtensions)
        {
            this.rootDir = repoRoot;
            this.gitignorePath = this.rootDir + @"\.gitignore";
            this.ignoreDirs = gitignoreDirs;
            this.ignoreExtensions = gitignoreExtensions;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public bool deleteGitignore()
        {
            if (File.Exists(this.gitignorePath))
            {
                File.Delete(this.gitignorePath);
                return true;
            }
            return false;
        }

        /// <summary>
        /// Creates a gitignore file
        /// </summary>
        /// <param name="errMsg"></param>
        /// <returns></returns>
        public bool createGitignore(out string errMsg)
        {
            string content = "";
            try
            {
                if (!File.Exists(gitignorePath))
                {
                    if (Directory.Exists(this.rootDir))
                    {
                        content = this.buildGitignore();
                        File.WriteAllText(gitignorePath, content);
                        errMsg = "";
                        return true;
                    }
                    else
                    {
                        errMsg = "Steam Game Path does not exist! Directory:<" + this.rootDir + ">";
                    }
                }
                errMsg = ".gitignore file already exist!";
            }
            catch (Exception ex)
            {
                errMsg = "Exception:<" + ex.Message + ">";
            }
            return false;
        }

        #region private_methods

        /// <summary>
        /// Helper to create the content of the .gitignore file.
        /// </summary>
        /// <returns></returns>
        private string buildGitignore()
        {
            // buffer
            string content = "";
            List<string> lineList = new List<string>();
            string itemTemp = "";

            // -- manual section 
            content = GitignoreHandler.addGitignoreSection(content, "Manually added files (add down below any file you want to gitignore)", false);
            content += "\r\n";

            // -- user extensions
            lineList.Clear();
            foreach (var item in this.ignoreExtensions)
            {
                itemTemp = "";
                if (item.StartsWith("."))
                {
                    item.Substring(1);
                }
                itemTemp = "*." + item;
                lineList.Add(itemTemp);
            }
            content = GitignoreHandler.addGitignoreSection(content, "Default extensions", true);
            content = GitignoreHandler.addLines(content, lineList);

            // -- user folders
            lineList.Clear();
            itemTemp = "";
            foreach (var item in this.ignoreDirs)
            {
                itemTemp = GitignoreHandler.gitignoreLineFormat(item) + "/*";
                lineList.Add(itemTemp);
            }
            content = GitignoreHandler.addGitignoreSection(content, "User defined folders", true);
            content = GitignoreHandler.addLines(content, lineList);

            // -- -- autogen section 
            if (Directory.Exists(rootDir))
            {
                string lineContent = "";
                lineList.Clear();
                foreach (string file in Directory.EnumerateFiles(this.rootDir,
                                                                 "*.*",
                                                                 System.IO.SearchOption.AllDirectories))
                {
                    lineContent = file.Replace(this.rootDir, "").Trim();
                    lineContent = GitignoreHandler.gitignoreLineFormat(lineContent);
                    if (this.addToAutogenSection(lineContent))
                    {
                        lineList.Add(lineContent);
                    }
                }
                content = GitignoreHandler.addGitignoreSection(content, "Augo-generated by spear.exe", true);
                content = GitignoreHandler.addLines(content, lineList);
            }
            return content;
        }

        /// <summary>
        /// Tells if the line content will be added or not to the lest section.
        /// </summary>
        /// <param name="lineContent"></param>
        /// <returns></returns>
        private bool addToAutogenSection(string lineContent)
        {
            lineContent.Trim();
            // starts with blacklist
            foreach (var item in this.constBlackListStartWith)
            {
                if (lineContent.StartsWith(item))
                {
                    return false;
                }
            }
            // files black list
            foreach (var item in this.constBlackListName)
            {
                if (item.Trim().Equals(lineContent))
                {
                    return false;
                }
            }
            // ignore dirs
            foreach (var item in this.ignoreDirs)
            {
                if (lineContent.StartsWith(item))
                {
                    return false;
                }
            }
            // ignore extension
            foreach (var item in this.ignoreExtensions)
            {
                if (lineContent.EndsWith(item))
                {
                    return false;
                }
            }
            // add item to list!
            return true;
        }

        /// <summary>
        /// helper to add a new comment-section
        /// </summary>
        /// <param name="gitignoreContent"></param>
        /// <param name="gitignoreSection"></param>
        /// <param name="skipLine"></param>
        /// <returns></returns>
        private static string addGitignoreSection(string gitignoreContent, string gitignoreSection, bool skipLine)
        {
            if (skipLine)
            {
                gitignoreContent += "\r\n";
            }
            string sectionContent = "#\r\n" + "# " + gitignoreSection + "\r\n" + "#\r\n";
            gitignoreContent += sectionContent;
            return gitignoreContent;
        }

        /// <summary>
        /// helper to let the line content in conformity with the scapes rules
        /// </summary>
        /// <returns></returns>
        private static  string gitignoreLineFormat(string lineToFormat)
        {
            lineToFormat.Trim();
            // replace \ bar by / bar
            lineToFormat = lineToFormat.Replace(@"\", @"/");
            // add scape characters whitespace " ", "[", "]"
            lineToFormat = lineToFormat.Replace(" ", @"\ ").Replace("[", @"\[").Replace("]", @"\]");
            // if the first character is /, skip it
            if (lineToFormat[0] == '/')
            {
                lineToFormat = lineToFormat.Substring(1);
            }
            return lineToFormat;
        }

        /// <summary>
        /// Add a lines from a list, one line by item.
        /// </summary>
        /// <param name="content"></param>
        /// <param name="lines"></param>
        /// <returns></returns>
        private static string addLines(string content, List<string> lines)
        {
            foreach (var item in lines)
            {
                content += item + "\r\n";
            }
            return content;
        }

        #endregion private_methods

    }
}
